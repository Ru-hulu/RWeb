# 程序本身做了哪些优化
    非阻塞IO + IO的多路复用
    1、非阻塞IO： 对于每个客户端建立的连接(accept返回的文件描述符),我们都设定为nonblock状态，这样可以避免一个socket出现可读事件时，我们开始读这个描述符，却发现没有数据。此时线程就会一直在此处停滞。非阻塞的设定可以让线程先去处理其他任务，提升并发处理的效率。
    2、IO多路复用：我们用了epoll，就是多路复用技术。采用了ET的触发模式，事件触发，更加高效。
    架构上：采用了线程池+任务队列的思路，main线程主要负责建立新的连接，并且将客户端的业务请求放到任务队列中，唤醒线程池中的线程来消耗队列中的任务。
    减少系统调用：设计了内存池，避免频繁的申请、释放内存
    减少系统调用：SendFile函数减少系统调用——正常发送文件：
        常规操作：
            read得到文件数据(一次系统调用，从用户态切换到内核态，读取数据到内核缓冲区)
            read调用完毕后(内核态切换到用户态，内核缓冲区被拷贝到用户缓冲区)
            write调用(一次系统调用，从用户态转到内核态，用户缓冲区数据写到套接字中)
            数据被发送到网络中，内核态转换到用户态
            两次拷贝，四次跳转
        SendFile操作：
            一次系统调用，用户态转到内核态，直接将磁盘中的数据拷贝到套接字缓冲区。发送完毕后从内核态转到用户态。    
    设置文件描述符上限：   
    设计中普遍使用了单例模式中的懒汉法
# 关于设计模式——我们采用了单Reactor多线程的设计模式
    Reactor: 是Webserver这种与网络连接应用相关程序的一种设计思想。
    含义：对事件响应，我们在epoll_wait中返回的就是 发生事件的连接。
    定义：同步、非阻塞设计模式
        非阻塞：我们为每个socket套接字设计的都是非阻塞。
        同步：在处理事件时，我们调用了read进行操作。这个动作是同步的：因为当有数据可以读取时，read这个系统调用需要等待磁盘拷贝到内核缓冲区，内核缓冲区拷贝到用户缓冲区。

    与之对比的是
    Proactor: 是Webserver这种与网络连接应用相关程序的一种设计思想。
    含义：对完成的事件响应
    定义：异步、非阻塞设计模式
        异步：我们只需要注册一个连接的相关事件即可，内核在处理完事件以后，会返回已经处理完成的事件。无需用户再调用read write等系统调用。
    Linux下只能用户模拟Proactor，所以不用。

    Reactor三种常见模式：
        1、单线程单Reactor：一个线程检查事件响应，负责连接、业务处理、发送数据
        2、多线程单Reactor：
                        主线程检查事件响应，负责连接，收发数据
                        业务处理被分发到其他线程处理
                        (我们采用的就是这种，但是不严格，因为收发read write其实不在主线程进行，而是在线程池中的其他线程进行)
        3、多线程多Reactor：
                        主线程负责连接，将连接分配给其他线程维护
                        其他线程各自检查连接的事件，进行响应和收发数据

# epoll select poll 都是多路复用，他们的差异、应用场景是什么
    1、从FD维护上来看，epoll 用红黑树， select 用线性表， poll 用链表
    2、从内核态切换上，epoll 每一次添加文件描述符都是系统调用，而select 和 poll的文件描述符都在用户态中，每次调用都需要全部拷贝到内核态一次
    3、从事件返回上看，epoll 每个文件描述符有一个回调函数，而select 和 poll每次都需要遍历所有描述符才能得到发生事件的描述符集合(耗时长)
    4、从事件触发机制上，epoll 支持ET LT ，其他只支持LT

    很多短期活跃连接，则 epoll可能更慢(2)，连接多的场景，epoll合适(3)，开发上epoll更灵活(4)。